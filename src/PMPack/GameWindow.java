/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package PMPack;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Random;

public class GameWindow extends javax.swing.JFrame {

    /**
     * Creates new form GameWindow
     */
    public GameWindow() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        WidthTextField = new javax.swing.JTextField();
        WidthLabel = new javax.swing.JLabel();
        HeightLabel = new javax.swing.JLabel();
        HeightTextField = new javax.swing.JTextField();
        RunButton = new javax.swing.JButton();
        PlayButton = new javax.swing.JButton();
        StopButton = new javax.swing.JButton();
        LeftButton = new javax.swing.JButton();
        UpButton = new javax.swing.JButton();
        DownButton = new javax.swing.JButton();
        RightButton = new javax.swing.JButton();
        TextPanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        WidthTextField.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N

        WidthLabel.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        WidthLabel.setText("Width:");

        HeightLabel.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        HeightLabel.setText("Height:");

        HeightTextField.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N

        RunButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        RunButton.setText("RUN");
        RunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RunButtonActionPerformed(evt);
            }
        });

        PlayButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        PlayButton.setText("PLAY KEYBOARD");
        PlayButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PlayButtonActionPerformed(evt);
            }
        });

        StopButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        StopButton.setText("STOP");
        StopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StopButtonActionPerformed(evt);
            }
        });

        LeftButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        LeftButton.setText("LEFT");
        LeftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LeftButtonActionPerformed(evt);
            }
        });

        UpButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        UpButton.setText("UP");
        UpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UpButtonActionPerformed(evt);
            }
        });

        DownButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        DownButton.setText("DOWN");
        DownButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DownButtonActionPerformed(evt);
            }
        });

        RightButton.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        RightButton.setText("RIGHT");
        RightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RightButtonActionPerformed(evt);
            }
        });

        TextPanel.setBackground(new java.awt.Color(255, 255, 255));
        TextPanel.setFont(new java.awt.Font("Verdana", 0, 14)); // NOI18N
        TextPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                TextPanelMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout TextPanelLayout = new javax.swing.GroupLayout(TextPanel);
        TextPanel.setLayout(TextPanelLayout);
        TextPanelLayout.setHorizontalGroup(
            TextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        TextPanelLayout.setVerticalGroup(
            TextPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 467, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(TextPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(WidthLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(WidthTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(HeightLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(LeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(UpButton, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(DownButton, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(RightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(HeightTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 153, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(RunButton, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(PlayButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(StopButton, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 318, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(WidthLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(WidthTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(HeightLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(HeightTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(RunButton, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(PlayButton, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(StopButton, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(LeftButton, javax.swing.GroupLayout.DEFAULT_SIZE, 34, Short.MAX_VALUE)
                    .addComponent(UpButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(DownButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(RightButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(7, 7, 7)
                .addComponent(TextPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void RunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RunButtonActionPerformed
        // TODO add your handling code here:
        TextPanel.paintComponents(copy);
        graph = (Graphics2D)TextPanel.getGraphics();
        
        int wid = Integer.parseInt(WidthTextField.getText());
        int heig = Integer.parseInt(HeightTextField.getText());
        MazeBuilderClass mazeBuild = new MazeBuilderClass(wid, heig);
        mazeBuild.generator();
        maze.clear();
        maze = mazeBuild.outMaze();
        width = maze.get(0).size();
        height = maze.size();
        borderX = mazeBuild.getBordWid();
        borderY = mazeBuild.getBordHigh();
        mazeDiff.clear();
        //init the maze
        for (int i = 0; i < height; i++){
            mazeDiff.add(new ArrayList<>());
            mazeG1.add(new ArrayList<>());
            mazeG2.add(new ArrayList<>());
            mazeG3.add(new ArrayList<>());
            mazeG4.add(new ArrayList<>());
            for (int j = 0; j < width; j++){
                boolean reach = maze.get(i).get(j) != 1;
                mazeDiff.get(i).add(new CellClass(j, i, reach));
                mazeG1.get(i).add(new CellClass(j, i, reach));
                mazeG2.get(i).add(new CellClass(j, i, reach));
                mazeG3.get(i).add(new CellClass(j, i, reach));
                mazeG4.get(i).add(new CellClass(j, i, reach));
            }
        }
        
        graph = paintMaze();
        TextPanel.paintComponents(graph);
        TextPanel.setVisible(true);  
    }//GEN-LAST:event_RunButtonActionPerformed

    private void StopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StopButtonActionPerformed
        // TODO add your handling code here:
        running = false;
        
        TextPanel.paintComponents(copy);
        int x = 0;
        int y = 0;
        for (int i = 0; i < height; i++){
            for (int j = 0; j < width; j++){
                graph.setColor(Color.WHITE);
                graph.fillRect(x, y, scale, scale);
                x += scale;
            }
            x = 0;
            y += scale;
        }
        maze.clear();
        mazeDiff.clear();
        finalized.clear();
        goalX = -1;
        goalY = -1;
        xCoord = 0;
        yCoord = 0;
    }//GEN-LAST:event_StopButtonActionPerformed

    private void PlayButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PlayButtonActionPerformed
        // TODO add your handling code here:
        ghost1 = new Thread();
        ghost2 = new Thread();
        ghost3 = new Thread();
        ghost4 = new Thread();
        graph = (Graphics2D)TextPanel.getGraphics();
        int counter = 1;
        for (int i = 0; i < height; i++){
            for (int j = 0; j < width; j++){
                if (maze.get(i).get(j) == 100){
                    graph.setColor(Color.WHITE);
                    graph.fillRect(j * scale, i * scale, scale, scale);
                    graph.setColor(Color.MAGENTA);
                    graph.fillOval(j * scale, i * scale, scale, scale);
                    switch(counter){
                        case 1:
                            ghost1 = new Thread(new Ghost(j, i, borderX, borderY, 0, 0, mazeG1));
                            counter++;
                            break;
                        case 2:
                            ghost2 = new Thread(new Ghost(j, i, width - 1, borderY, borderX + 1, 0, mazeG2));
                            counter++;
                            break;
                        case 3:
                            ghost3 = new Thread(new Ghost(j, i, borderX, height - 1, 0, borderY + 1, mazeG3));
                            counter++;
                            break;
                        case 4:
                            ghost4 = new Thread(new Ghost(j, i, width - 1, height - 1, borderX + 1, borderY + 1, mazeG4));
                            counter++;
                            break;
                        default:
                            break;
                    }
                }
            }
        }
        
        //now we need the algorithms for the ghosts to move
        //they have to move constantly unless the game is turned off or the Pacman is dead
        //the Threads maybe?
        running = true;
        ghost1.start();
        ghost2.start();
        ghost3.start();
        ghost4.start();
    }//GEN-LAST:event_PlayButtonActionPerformed

    private void LeftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LeftButtonActionPerformed
        // TODO add your handling code here:
        if (maze.get(yCoord).get(xCoord - 1) != 1){
            if (paintOnGraph(2, (xCoord - 1), yCoord, xCoord, yCoord))
                xCoord--;
        }
    }//GEN-LAST:event_LeftButtonActionPerformed

    private void UpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UpButtonActionPerformed
        // TODO add your handling code here:
        if (maze.get(yCoord - 1).get(xCoord) != 1){
            if (paintOnGraph(2, xCoord, (yCoord - 1), xCoord, yCoord))
                yCoord--;
        }
    }//GEN-LAST:event_UpButtonActionPerformed

    private void DownButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DownButtonActionPerformed
        // TODO add your handling code here:
        if (maze.get(yCoord + 1).get(xCoord) != 1){
            if (paintOnGraph(2, xCoord, (yCoord + 1), xCoord, yCoord))
                yCoord++;
        }
    }//GEN-LAST:event_DownButtonActionPerformed

    private void RightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RightButtonActionPerformed
        // TODO add your handling code here:
        if (maze.get(yCoord).get(xCoord + 1) != 1){
            if (paintOnGraph(2, (xCoord + 1), yCoord, xCoord, yCoord))
                xCoord++;
        }
    }//GEN-LAST:event_RightButtonActionPerformed

    private void TextPanelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_TextPanelMouseClicked
        // TODO add your handling code here:
        int x = evt.getX();
        int y = evt.getY();
        x = x / scale;
        y = y / scale;
        graph = (Graphics2D)TextPanel.getGraphics();
        if (x < width && y < height){
            if (maze.get(y).get(x) != 1){
                if (goalX != -1 && goalY != -1){
                    graph.setColor(Color.WHITE);
                    graph.fillRect(goalX * scale, goalY * scale, scale, scale);
                    maze.get(goalY).set(goalX, 0);
                }
                graph.setColor(Color.GREEN);
                graph.fillRect(x * scale, y * scale, scale, scale);
                goalX = x;
                goalY = y;
                maze.get(y).set(x, 3);
            }
        }
        if (evt.getButton() == MouseEvent.BUTTON1){
            AStar();
        }
        else if (evt.getButton() == MouseEvent.BUTTON3){
            Greedy();
        }
        TextPanel.paintComponents(graph);
        TextPanel.setVisible(true);
    }//GEN-LAST:event_TextPanelMouseClicked

    public static Comparator<CellClass> cellComparatorF = new Comparator<CellClass>(){
         
        @Override
        public int compare(CellClass c1, CellClass c2) {
            int res = Integer.compare(c1.getF(), c2.getF());
            return res;
        }
    };
    
    public static Comparator<CellClass> cellComparatorH = new Comparator<CellClass>(){
         
        @Override
        public int compare(CellClass c1, CellClass c2) {
            int res = Integer.compare(c1.getH(), c2.getH());
            return res;
        }
    };
    
    public class Ghost implements Runnable{  //Runnable makes the class able of creating a Thread
        int x, y, xLim, yLim, xBeg, yBeg;
        ArrayList<CellClass> finalizedArray;
        ArrayList<CellClass> path;
        ArrayList<ArrayList<CellClass>> mazeForScan;
        int keepX, keepY;  //last Pacman pos detected
        int curIndex;  //at which index of the path we are
        public Ghost(int X, int Y, int XLim, int YLim, int XBeg, int YBeg, ArrayList<ArrayList<CellClass>> m){
            x = X;
            y = Y;
            xLim = XLim;
            yLim = YLim;
            xBeg = XBeg;
            yBeg = YBeg;
            keepX = xCoord;
            keepY = yCoord;
            mazeForScan = new ArrayList<>();
            mazeForScan.addAll(m);
            path = new ArrayList<>();
            finalizedArray = new ArrayList<>();
            curIndex = 0;
        }
        
        public void run(){
            try{
                while(running){
                    //if the Pacman is inside the patrol sector, move towards it
                    if (xCoord >= xBeg && yCoord >= yBeg && xCoord <= xLim && yCoord <= yLim){
                        if (xCoord != keepX || yCoord != keepY || path.isEmpty()){
                            //if Pacman changed its position, recalculate the path
                            //if there's a path already, clear it
                            if (!path.isEmpty()){
                                path.clear();
                                finalizedArray.clear();
                            }        
                            curIndex = 0;
                            keepX = xCoord;
                            keepY = yCoord;
                            ArrayList<CellClass> toLook = new ArrayList<>();
                            ArrayList<CellClass> heap = new ArrayList<>();
                
                            //A* algorithm (COPIED code)
                            CellClass start = new CellClass(x, y, true);
                            start.setG(-1);
                            updateAdjCell(mazeForScan.get(y).get(x), start);
                            heap.add(mazeForScan.get(y).get(x));  //add the starting point
        
                            while (!heap.isEmpty()){
                                CellClass curCell = heap.get(0);  //pop the cell from queue
                                heap.remove(0);
                                finalizedArray.add(mazeForScan.get(curCell.getY()).get(curCell.getX()));
                                if (curCell.getX() == keepX && curCell.getY() == keepY)
                                    break;  //if the end's reached, break
            
                                //if not, get adjusted cells
                                toLook.clear();
                                toLook = getAdj(curCell);
                                for (int i = 0; i < toLook.size(); i++){
                                    if (toLook.get(i).getReach() && !finalizedArray.contains(toLook.get(i))){
                                        if (heap.contains(toLook.get(i))){
                                            if (toLook.get(i).getG() > curCell.getG() + 1)
                                                updateAdjCell(toLook.get(i), curCell);
                                        }
                                        else{
                                            updateAdjCell(toLook.get(i), curCell);
                                            heap.add(toLook.get(i));
                                        }
                                    }
                                }
                                Collections.sort(heap, cellComparatorF);
                            }
        
                            //Make the path
                            CellClass end = mazeForScan.get(keepY).get(keepX);
                            path.add(mazeForScan.get(keepY).get(keepX));
                            while (true){
                                CellClass par = end.getParent();
                                if (par != null && !(par.getX() == x && par.getY() == y)){
                                    path.add(0, mazeForScan.get(par.getY()).get(par.getX()));
                                    end = par;
                                }
                                else
                                    break;
                            }  
                            path.add(0, mazeForScan.get(y).get(x));
                        }
                    
                        //Follow the path
                        int move = curIndex + 1 == path.size() ? curIndex : curIndex + 1;
                        int shiftX = path.get(move).getX() - path.get(curIndex).getX();
                        int shiftY = path.get(move).getY() - path.get(curIndex).getY();
                        if (shiftX == -1){
                            moveLeft();
                            curIndex++;
                            Thread.sleep(sleeping);
                        }
                        else if (shiftX == 1){
                            moveRight();
                            curIndex++;
                            Thread.sleep(sleeping);
                        }
                        else if (shiftY == -1){
                            moveUp();
                            curIndex++;
                            Thread.sleep(sleeping);
                        }
                        else if (shiftY == 1){
                            moveDown();
                            curIndex++;
                            Thread.sleep(sleeping);
                        }
                    }
                    
                    //if it's not, move around the sector randomly
                    else{
                        Random rand = new Random();
                        ArrayList<String> directions = new ArrayList<>();
                        if ((maze.get(y).get(x - 1) == 0 || maze.get(y).get(x - 1) == 2) && (x - 1) >= xBeg)
                            directions.add("left");
                        if ((maze.get(y).get(x + 1) == 0 || maze.get(y).get(x + 1) == 2) && (x + 1) <= xLim)
                            directions.add("right");
                        if ((maze.get(y - 1).get(x) == 0 || maze.get(y - 1).get(x) == 2) && (y - 1) >= yBeg)
                            directions.add("up");
                        if ((maze.get(y + 1).get(x) != 1 || maze.get(y + 1).get(x) == 2) && (y + 1) <= yLim)
                            directions.add("down");
                        if (!directions.isEmpty()){
                            int r = rand.nextInt(directions.size());
                            String moving = directions.get(r);
                            switch(moving){
                                case "left":
                                    moveLeft();
                                    Thread.sleep(sleeping);
                                    break;
                                case "right":
                                    moveRight();
                                    Thread.sleep(sleeping);
                                    break;
                                case "up":
                                    moveUp();
                                    Thread.sleep(sleeping);
                                    break;
                                case "down":
                                    moveDown();
                                    Thread.sleep(sleeping);
                                    break;
                            }
                        }
                    directions.clear();
                    }
                    if (x == xCoord && y == yCoord){
                        running = false;
                    }
                }
            }
            catch(Exception ex){
                
            }
        }
        private void moveLeft(){
            if (paintOnGraph(100, x - 1, y, x, y))
                x--;
        }
        
        private void moveRight(){
            if (paintOnGraph(100, x + 1, y, x, y))
                x++;
        }
        
        private void moveUp(){
            if (paintOnGraph(100, x, y - 1, x, y))
                y--;
        }
        
        private void moveDown(){
            if (paintOnGraph(100, x, y + 1, x, y))
                y++;
        }
        
        private ArrayList<CellClass> getAdj(CellClass cell){
            ArrayList<CellClass> cells = new ArrayList<>();
            if (maze.get(cell.getY()).get(cell.getX() - 1) != 1)
                cells.add(mazeForScan.get(cell.getY()).get(cell.getX() - 1));
            if (maze.get(cell.getY()).get(cell.getX() + 1) != 1)
                cells.add(mazeForScan.get(cell.getY()).get(cell.getX() + 1));
            if (maze.get(cell.getY() - 1).get(cell.getX()) != 1)
                cells.add(mazeForScan.get(cell.getY() - 1).get(cell.getX()));
            if (maze.get(cell.getY() + 1).get(cell.getX()) != 1)
                cells.add(mazeForScan.get(cell.getY() + 1).get(cell.getX()));
            return cells;
        }
    }
    
    public synchronized boolean paintOnGraph(int det, int x, int y, int prevX, int prevY){
        graph = (Graphics2D)TextPanel.getGraphics();
        if (maze.get(y).get(x) == 100 && maze.get(prevY).get(prevX) == 100)  //if on next step two ghosts will collide
            return false;
        if (det == 100){
            maze.get(prevY).set(prevX, 0);
            maze.get(y).set(x, det);
            graph.setColor(Color.WHITE);
            graph.fillRect(prevX * scale, prevY * scale, scale, scale);
            graph.setColor(Color.MAGENTA);
            graph.fillOval(x * scale, y * scale, scale, scale);
        }
        else{
            maze.get(prevY).set(prevX, 0);
            maze.get(y).set(x, det);
            graph.setColor(Color.WHITE);
            graph.fillRect(prevX * scale, prevY * scale, scale, scale);
            graph.setColor(Color.YELLOW);
            graph.fillOval(x * scale, y * scale, scale, scale);
        }
        TextPanel.paintComponents(graph);
        TextPanel.setVisible(true);
        return true;
    }
    
    
    private static void AStar(){
        TextPanel.paintComponents(copy);
        graph = (Graphics2D)TextPanel.getGraphics();
        
        //if there's a path already, clear it
        if (!finalized.isEmpty()){
            for (int i = 0; i < finalized.size(); i++){
                graph.setColor(Color.WHITE);
                graph.fillRect(finalized.get(i).getX() * scale, finalized.get(i).getY() * scale, scale, scale);
            }
            finalized.clear();
        }
        
        ArrayList<CellClass> toLook = new ArrayList<>();
        ArrayList<CellClass> heap = new ArrayList<>();
        
        //algorithm
        CellClass start = new CellClass(xCoord, yCoord, true);
        start.setG(-1);
        updateAdjCell(mazeDiff.get(yCoord).get(xCoord), start);
        heap.add(mazeDiff.get(yCoord).get(xCoord));  //add the starting point
        
        while (!heap.isEmpty()){
            CellClass curCell = heap.get(0);  //pop the cell from queue
            heap.remove(0);
            finalized.add(mazeDiff.get(curCell.getY()).get(curCell.getX()));  //we don't need to process the cell twice
            if (curCell.getX() == goalX && curCell.getY() == goalY)
                break;  //if the end's reached, break
            
            //if not, get adjusted cells
            toLook.clear();
            toLook = getAdjusted(curCell);
            for (int i = 0; i < toLook.size(); i++){
                if (toLook.get(i).getReach() && !finalized.contains(toLook.get(i))){
                    if (heap.contains(toLook.get(i))){
                        if (toLook.get(i).getG() > curCell.getG() + 1)
                            updateAdjCell(toLook.get(i), curCell);
                    }
                    else{
                        updateAdjCell(toLook.get(i), curCell);
                        heap.add(toLook.get(i));
                    }
                }
            }
            //This is important! Keep the cell with the lowest F on top
            Collections.sort(heap, cellComparatorF);
        }
        
        //Output
        graph = paintMaze();
        CellClass end = mazeDiff.get(goalY).get(goalX);
        while (true){
            CellClass par = end.getParent();
            if (par != null && !(par.getX() == xCoord && par.getY() == yCoord)){
                graph.setColor(Color.RED);
                graph.fillRect(par.getX() * scale, par.getY() * scale, scale, scale);
                end = par;
            }
            else
                break;
        }
        
        graph.setColor(Color.GREEN);
        graph.fillRect(goalX * scale, goalY * scale, scale, scale);
        graph.setColor(Color.WHITE);
        graph.fillRect(xCoord * scale, yCoord * scale, scale, scale);
        graph.setColor(Color.YELLOW);
        graph.fillOval(xCoord * scale, yCoord * scale, scale, scale);
        
        TextPanel.paintComponents(graph);
        TextPanel.setVisible(true);
    }
    
    private static void Greedy(){
        TextPanel.paintComponents(copy);
        graph = (Graphics2D)TextPanel.getGraphics();
        
        //if there's a path already, clear it
        if (!finalized.isEmpty()){
            for (int i = 0; i < finalized.size(); i++){
                graph.setColor(Color.WHITE);
                graph.fillRect(finalized.get(i).getX() * scale, finalized.get(i).getY() * scale, scale, scale);
            }
            finalized.clear();
        }
        
        ArrayList<CellClass> toLook = new ArrayList<>();
        ArrayList<CellClass> heap = new ArrayList<>();
        
        //algorithm
        CellClass start = new CellClass(xCoord, yCoord, true);
        start.setG(-1);
        updateAdjCell(mazeDiff.get(yCoord).get(xCoord), start);
        heap.add(mazeDiff.get(yCoord).get(xCoord));  //add the starting point
        
        while (!heap.isEmpty()){
            CellClass curCell = heap.get(0);  //pop the cell from queue
            heap.remove(0);
            finalized.add(mazeDiff.get(curCell.getY()).get(curCell.getX()));  //we don't need to process the cell twice
            if (curCell.getX() == goalX && curCell.getY() == goalY)
                break;  //if the end's reached, break
            
            //if not, get adjusted cells
            toLook.clear();
            toLook = getAdjusted(curCell);
            //The Greedy algorithm explores the nodes with the least Heuristic distance first
            for (int i = 0; i < toLook.size(); i++){
                if (toLook.get(i).getReach() && !finalized.contains(toLook.get(i))){
                    if (heap.contains(toLook.get(i))){
                        if (toLook.get(i).getH() > curCell.getH())
                            updateAdjCell(toLook.get(i), curCell);
                    }
                    else{
                        updateAdjCell(toLook.get(i), curCell);
                        heap.add(toLook.get(i));
                    }
                }
            }
            //This is important! Keep the cell with the lowest H on top
            Collections.sort(heap, cellComparatorH);
        }
        
        //Output
        graph = paintMaze();
        CellClass end = mazeDiff.get(goalY).get(goalX);
        while (true){
            CellClass par = end.getParent();
            if (par != null && !(par.getX() == xCoord && par.getY() == yCoord)){
                graph.setColor(Color.ORANGE);
                graph.fillRect(par.getX() * scale, par.getY() * scale, scale, scale);
                end = par;
            }
            else
                break;
        }
        
        graph.setColor(Color.GREEN);
        graph.fillRect(goalX * scale, goalY * scale, scale, scale);
        graph.setColor(Color.WHITE);
        graph.fillRect(xCoord * scale, yCoord * scale, scale, scale);
        graph.setColor(Color.YELLOW);
        graph.fillOval(xCoord * scale, yCoord * scale, scale, scale);
        
        TextPanel.paintComponents(graph);
        TextPanel.setVisible(true);
    }
    
    public static int getHeuristic(CellClass cell){
        int h = Math.abs(cell.getX() - goalX) + Math.abs(cell.getY() - goalY);
        return h;
    }
    
    public static ArrayList<CellClass> getAdjusted(CellClass cell){
        ArrayList<CellClass> cells = new ArrayList<>();
        if (maze.get(cell.getY()).get(cell.getX() - 1) != 1)
            cells.add(mazeDiff.get(cell.getY()).get(cell.getX() - 1));
        if (maze.get(cell.getY()).get(cell.getX() + 1) != 1)
            cells.add(mazeDiff.get(cell.getY()).get(cell.getX() + 1));
        if (maze.get(cell.getY() - 1).get(cell.getX()) != 1)
            cells.add(mazeDiff.get(cell.getY() - 1).get(cell.getX()));
        if (maze.get(cell.getY() + 1).get(cell.getX()) != 1)
            cells.add(mazeDiff.get(cell.getY() + 1).get(cell.getX()));
        return cells;
    }
    
    public static synchronized void updateAdjCell(CellClass cellToUp, CellClass par){
        cellToUp.setG(par.getG() + 1);
        cellToUp.setH(getHeuristic(cellToUp));
        cellToUp.setParent(par);
        cellToUp.setF(cellToUp.getH() + cellToUp.getG());
    }
    
    public static Graphics2D paintMaze(){
        Graphics2D graphic = (Graphics2D)TextPanel.getGraphics();
        int x = 0;
        int y = 0;
        for (int i = 0; i < height; i++){
            for (int j = 0; j < width; j++){
                if (maze.get(i).get(j) == 1){
                    graphic.setColor(Color.BLUE);
                    graphic.fillRect(x, y, scale, scale);
                }
                else if (maze.get(i).get(j) == 2){
                    graphic.setColor(Color.WHITE);
                    graphic.fillRect(x, y, scale, scale);
                    graphic.setColor(Color.YELLOW);
                    graphic.fillOval(x, y, scale, scale);
                    xCoord = j;
                    yCoord = i;
                }
                else{
                    graphic.setColor(Color.WHITE);
                    graphic.fillRect(x, y, scale, scale);
                }
                x += scale;
            }
            x = 0;
            y += scale;
        }
        return graphic;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GameWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GameWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GameWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GameWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GameWindow().setVisible(true);
                maze = new ArrayList<>();
                mazeDiff = new ArrayList<>();
                mazeG1 = new ArrayList<>();
                mazeG2 = new ArrayList<>();
                mazeG3 = new ArrayList<>();
                mazeG4 = new ArrayList<>();
                finalized = new ArrayList<>();
                graph = (Graphics2D)TextPanel.getGraphics();
                copy = (Graphics2D)TextPanel.getGraphics();
                height = 0;
                width = 0;
                xCoord = 0;
                yCoord = 0;
                running = true;
                goalX = -1;
                goalY = -1;
                borderX = 0;
                borderY = 0;
                sleeping = 1000;
                scale = 20;
            }
        });
    }

    private static ArrayList<ArrayList<Integer>> maze;
    private static ArrayList<ArrayList<CellClass>> mazeDiff;  //maze for Pacman
    private static ArrayList<ArrayList<CellClass>> mazeG1;  //mazes for ghosts
    private static ArrayList<ArrayList<CellClass>> mazeG2;
    private static ArrayList<ArrayList<CellClass>> mazeG3;
    private static ArrayList<ArrayList<CellClass>> mazeG4;
    private static ArrayList<CellClass> finalized;  //array for Pacman path searching
    
    private static Thread ghost1;
    private static Thread ghost2;
    private static Thread ghost3;
    private static Thread ghost4;
    
    private static Graphics2D graph;
    private static Graphics2D copy;
    private static int height;  //The field's dimentions
    private static int width;
    private static int xCoord;  //Pacman coords
    private static int yCoord;
    public static volatile boolean running;
    private static int goalX;
    private static int goalY;
    private static int borderX;  //dividors of 4 "sectors" of the field
    private static int borderY;
    
    private static int sleeping;
    private static int scale;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton DownButton;
    private javax.swing.JLabel HeightLabel;
    public javax.swing.JTextField HeightTextField;
    private javax.swing.JButton LeftButton;
    private javax.swing.JButton PlayButton;
    private javax.swing.JButton RightButton;
    private javax.swing.JButton RunButton;
    private javax.swing.JButton StopButton;
    public static javax.swing.JPanel TextPanel;
    private javax.swing.JButton UpButton;
    private javax.swing.JLabel WidthLabel;
    public javax.swing.JTextField WidthTextField;
    // End of variables declaration//GEN-END:variables
}
